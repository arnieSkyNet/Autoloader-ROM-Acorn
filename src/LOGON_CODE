LOGON	LDX	#>user_id_text	LDY	#<user_id_text	JSR	PRINT_TEXT	LDX	#>logon_data		; Get X & Y address of the	LDY	#<logon_data		; "I AM" data	JSR	MOVE_DOWN_MEMORY	; Move data into Parameter block	LDA	#32			; Load a Space character to insert	STA	param_blk+4		; into parameter buffer Location 4	LDX	#>param_blk		; Get the X & Y addres of the	LDY	#<param_blk		; parameter block.	TXA				; Add 5 to the Parameter X address	CLC				; so the User ID can be inserted	ADC	#05			; after the "I AM".	TAX				; Put new value of X back to X	LDA	#10			; Maximum number of characters	JSR	GET_NAME		; that the user can type in.	BCS	:no_esc_userID		; If Carry clear then no escape	JMP	:user_escapes		; was pressed. Else exit.:no_esc_userID	STY	file_num	CPY	#0			; If ID not typed then redo	BEQ	LOGONPASS_LOGON				; Now do LOGON	LDX	#>param_blk		; Get X & Y address of parameter	LDY	#<param_blk		; Block for OSCLI	STX	oscli_store	STY	oscli_store+1	LDA	#&FE	JSR	ERROR_OSCLI	BCC	:check_password_error	; If no error then Logon with no	RTS				; Password was successful. Exit!:check_password_error	LDA	#&FF			; A Password is required. Protect	JSR	WRITE_PROTECTION	; Machine from viewing & peeking.	LDY	#0	LDA	(&FD),Y			; Error Number	CMP	#188			; Error 188 = User not known	BNE	:get_password		; If error user not known then	CLC				; Clear carry to indicate error	RTS				; Exit!:get_password	LDX	#>password_text	LDY	#<password_text	JSR	PRINT_TEXT		; Print password text	LDX	#>param_blk	LDY	#<param_blk	TXA	CLC	ADC	#05	CLC	ADC	file_num	TAX		STX	Temp	STY	Temp+1	LDA	#32	LDY	#0	STA	(Temp),Y	INC	Temp:password_loop	JSR	OSRDCH	CMP	#13	BEQ	:end_logon	CMP	#27	BNE	:not_password_escape:user_escapes	JSR	OSNEWL	CLC				; Indicate user wants to exit	RTS:not_password_escape	CMP	#127	BNE	:not_password_del	CPY	#0	BEQ	:password_loop	JSR	OSWRCH	DEY	JMP	:password_loop:not_password_del	STA	(Temp),Y	LDA	#"*"	JSR	OSWRCH	INY	JMP	:password_loop:end_logon	STA	(Temp),Y	JSR	OSNEWL	LDX	#>param_blk	LDY	#<param_blk	JSR	OSCLI;	STX	oscli_store;	STY	oscli_store+1;	LDA	#&FE;	JSR	ERROR_OSCLI	SEC	BCS	:password_accepted	LDX	#>logon_data	LDY	#<logon_data      	JSR	MOVE_DOWN_MEMORY	LDA	#32	STA	param_blk+4	JMP	:get_password:password_accepted	LDX	#>param_blk		; Get address of *I AM <DD> <SS> 	LDY	#<param_blk		STX	Temp	STY	Temp+1	LDY	#0	TYA:clear_password_loop	STA	(Temp),Y		; Wipe memory of password & ID.	INY	CPY	#30	BNE	:clear_password_loop	LDA	#0			; Unprotect machine	JSR	WRITE_PROTECTION	LDA	#0	SEC				; Set carry to Indicate OK.	RTSLOGON_CODE	PLA	STA	text_add	PLA	STA	text_add+1	LDA	#0	STA	column_flag	STA	row_flag	LDY	#01:log_CL_loop	LDA	(&F2),Y	CMP	#13	BEQ	:do_logon_now	CMP	#"S"			; Check for Upper case S (Switches)	BEQ	:set_log_switches	CMP	#"s"			; Check for Lower case s (Switches)	BEQ	:set_log_switches	INY	JMP	:log_CL_loop:set_log_switches	LDA	#0	STA	column_flag	LDA	#02	STA	row_flag	JSR	MODE132	JSR	OSNEWL	JSR	OSNEWL	JSR	OSNEWL:do_logon_now	JSR	LOGON	JSR	DEFAULT_COLOUR	PLA	TAX	PLA	TAY	LDA	#0	RTSSYST_CODE	PLA	STA	text_add	PLA	STA	text_add+1	LDA	#0			; Make sure switch user	STA	column_flag		; keyboard doesn't kick in	STA	row_flag	LDX	#>logon_data		; Get X & Y address of the	LDY	#<logon_data		; "I AM" data	JSR	MOVE_DOWN_MEMORY	; Move data into Parameter block	LDA	#32			; Load a Space character to insert	STA	param_blk+4		; into parameter buffer Location 4	LDX	#05			; Where to save ID if any	LDY	#05			; Where to get ID from CL:get_logon_user_id	LDA	(&F2),Y	CMP	#13	BEQ	:cl_has_been_terminated	STA	param_blk,X	INY	INX	CPX	#15	BNE	:get_logon_user_id:cl_has_been_terminated	CPX	#05			; Check if any user ID was passed	BEQ	:successful_logon	; to the CL.	LDA	#13	STA	param_blk,X	JSR	PASS_LOGON	BCS	:successful_logon 	JMP	:exit_syst_logon	; Exit ROM as went wrong.; Here we start reading the current pathname and then Logon as SYST:successful_logon			; User no logged on as specified.	JSR	GET_PATHNAME_CODE	; Now we read the pathname.	BEQ	:skip_exit_syst	JMP	:exit_syst_logon:skip_exit_syst		LDX	#>logon_data		; Now logon as System Manager.	LDY	#<logon_data	JSR	MOVE_DOWN_MEMORY	LDA	#32	LDX	#>syst_ID_name	LDY	#<syst_ID_name	JSR	OSCLI;	STA	param_blk+4;	LDA	#"S";	STA	param_blk+5;	LDA	#"Y";	STA	param_blk+6	;	LDA	#"S";	STA	param_blk+7;	LDA	#"T";	STA	param_blk+8;	LDA	#13;	STA	param_blk+9;	LDA	#04     		; Length of USER ID SYST	LDY	#04	LDX	#&FF:find_syst_id_length	INX	INY	LDA	small_buffer,X	STA	param_blk,Y	CMP	#13	BNE	:find_syst_id_length	TYA	SEC	SBC	#05	STA	file_num	JSR	PASS_LOGON	BCS	:goto_csd:password_went_wrong	JMP	:exit_syst_logon	; Exit ROM as went wrong.:goto_csd	LDA	#&FE			; Set pointer up to equal 0	STA	file_num		; And store value to be read.	JSR	GET_BACK_INTO_CSD	; Enter CSD through pathname.:exit_syst_logon	PLA	TAX	PLA	TAY	LDA	#0	RTS