; 	SIZE	DATE		VERS.	ADDITION/BUG;-----------------------------------------------------------------------;	&3F84	12 May 92	3.09	*G_CSD Misses first character.;	&3F84	13 May 92	3.0A	*G_CSD bug fixed.;	&3F7C	13 May 92	3.0A	Now trying to shrink code....;	&3EDC	13 May 92	3.0A	Finished shrink for now.;	&3F1B	13 May 92	3.0B	(F 0-7) CL's Now Implemented;	&3F2B	18 May 92	3.0C	Display title on break.;	&3F36	19 May 92	3.0D	Tidy up somewhat.;	&3F69	19 May 92	3.0E	View to load Unknowns;	&3F13	20 May 92	3.0F	*LOAD DIRS & MATCH WORDS ALTERED;	&3F46	20 May 92	3.10	Speed up keyboard response;	&3FD0	22 May 92	3.11	*D_OBJECTS Display and choose.;	&3FC5	1  Jun 92	3.11	Above finished and working.;	&3FE4	5  Jun 92	3.12	Flash Header on Break.;	&3F8B	8  Jun 92	3.13	New copy facility for Mary.;	&3FB3	11 Jun 92	3.14	Chime OFF (CL) change Params.;				3.15	*D_OBJECTS causes error when					;					Returning to BASIC???;	&3FB8	22 Jun 92	3.16	Needed an extra PHA before PLA.;	&3FDB	30 Jun 92	3.16	System Managers ID can be anything;	&3FE1	1  Jul 92	3.16	*D_OBJECTS now clears up Zero page;	&3FE0	3  Jul 92	3.17	Exit AL without error if no AL_UTIL;	&3FE8	17 Jul 92	3.17	CL=#=exit (AutoRom is Resident);	&3FE6	17 Jul 92	3.17	*G_OBJECT_TYPE ?&70=Obj number	;	&3FFA	11 Nov 92	3.18	*G_PATHNAME & *PATHNAME when in $;	&3FF8	29 Mar 93	3.19	Everyone to staff menuROM_START	DFB	0		DFB	0	DFB	0	JMP	:service	DFB	&82	DFB	:copywrite-ROM_START	DFB	&01:title	ASC	"Autoloader"	DFB	0	ASC	"3.19"	DFB	13:copywrite	DFB	0	STR	"(C) 1992 Mark Worsdall"	DFB	0:star_commands	ASC	"*AUTOLOAD"	DFB	<AUTOLOAD_CODE	DFB	>AUTOLOAD_CODE	ASC	"*SYST"	DFB	<SYST_CODE	DFB	>SYST_CODE	ASC	"*PATHNAME"	DFB	<PATHNAME_CODE	DFB	>PATHNAME_CODE	ASC	"*NET_TEST"	DFB	<NET_TEST_CODE	DFB	>NET_TEST_CODE	ASC	"*LOGON"	DFB	<LOGON_CODE	DFB	>LOGON_CODE	ASC	"*FASTKEY"	DFB	<FASTKEY_CODE	DFB	>FASTKEY_CODE	ASC	"*CONFIG"	DFB	<CONFIGURE_CODE	DFB	>CONFIGURE_CODE	ASC	"*G_CSD"	DFB	<G_CSD_CODE	DFB	>G_CSD_CODE	ASC	"*G_OBJECTS"	DFB	<G_OBJECTS_CODE	DFB	>G_OBJECTS_CODE	ASC	"*G_DISCTITLE"	DFB	<G_DISCTITLE_CODE	DFB	>G_DISCTITLE_CODE	ASC	"*G_USER"	DFB	<G_USER_CODE	DFB	>G_USER_CODE	ASC	"*G_STATION"	DFB	<G_STATION_CODE	DFB	>G_STATION_CODE	ASC	"*G_MACHINE"	DFB	<G_MACHINE_CODE	DFB	>G_MACHINE_CODE	ASC	"*G_PATHNAME"	DFB	<G_PATHNAME_CODE	DFB	>G_PATHNAME_CODE	ASC	"*G_OBJECT_TYPE"	DFB	<G_OBJECT_TYPE_CODE	DFB	>G_OBJECT_TYPE_CODE	ASC	"*D_OBJECTS"	DFB	<D_OBJECTS_CODE	DFB	>D_OBJECTS_CODE	DFB	0	:service	CMP	#&27	BEQ	:display_on_break	JMP	:not_auto_boot:display_on_break	PHA	PHP	TYA	PHA	TXA	PHA	LDA	#&FD	LDX	#0	LDY	#&FF	JSR	OSBYTE		; Read hard/soft BREAK	TXA	BEQ	:zero_break_set2	LDA	#01	BNE	:skip_setting_zero2:zero_break_set2	LDA	#02:skip_setting_zero2	LDX	&F4	STA	&0DF0,X	JSR	INVERSE_COLOUR:skip_break_inverse	LDX	#0:print_rom_title_loop2	LDA	:title,X		BNE	:over_1a	LDA	#&20:over_1a	JSR	OSASCI	INX	CPX	#:copywrite-:title	BNE	:print_rom_title_loop2	JSR	DEFINE_CHARACTERS	LDA	#20	JSR	OSWRCH	JSR	OSNEWL	PLA	TAX	PLA	TAY	PLP	PLA	RTS:not_auto_boot	CMP	#04	BNE	:not_command	JMP	:command:not_command	CMP	#09	BEQ	:help  	RTS:help	TYA	PHA	TXA	PHA	LDA	Temp	PHA	LDA	Temp+1	PHA	JSR	OSNEWL	LDX	#0:print_rom_title_loop	LDA	:title,X		BNE	:over_1	LDA	#&20:over_1	JSR	OSASCI	INX	CPX	#:copywrite-:title	BNE	:print_rom_title_loop	TYA	BEQ	:exit_print_help	LDX	#0:comm_loop	LDA	(&F2),Y	CMP	#"."	BEQ	:its_mine	CMP	:title,X	BNE	:exit_print_help	CMP	#13	BEQ	:its_mine	INX	INY	CPX	#07	BEQ	:its_mine	JMP	:comm_loop:its_mine	LDA	#09	JSR	OSWRCH	JSR	OSWRCH	LDX	#>:star_commands	LDY	#<:star_commands	STX	Temp	STY	Temp+1	LDY	#&FF:print_test_loop	INY	LDA	(Temp),Y	BEQ	:exit_print_help_final	CMP	#&7F	BPL	:skip_garbage	CMP	#"*"	BEQ	:print_test_loop	JSR	OSWRCH	JMP	:print_test_loop:skip_garbage	JSR	OSNEWL	LDA	#09	JSR	OSWRCH	JSR	OSWRCH	JSR	STORE_BEGIN_ADDRESS	LDY	#&FF	JMP	:print_test_loop:exit_print_help_final	JSR	OSNEWL:exit_print_help	PLA	STA	Temp+1	PLA		STA	Temp	PLA	TAX	PLA	TAY	LDA	#09	RTS:command	TYA	PHA	TXA	PHA	LDA	text_add	PHA	LDA	text_add+1	PHA	LDA	Temp	PHA	LDA	Temp+1	PHA	LDA	text_pos	PHA	LDA	text_pos+1	PHA	LDX	#>:star_commands	; Get address of star command	LDY	#<:star_commands	; List	STX	Temp			; Store addess in Temp	STY	Temp+1	LDY	#&FF			; Set Y ready to INY to 0:name_test_loop	INY	LDA	(Temp),Y	CMP	#&7F			; If byte greater than &80	BPL	:enter_chosen_code	; Then enter this code	LDA	(&F2),Y			; Load A with command line byte	CMP	#"."			; Test to see if short hand "."	BNE	:not_full_stop	 	; If = "." branch to enter code	JSR	GET_TO_CODE_ADDRESS	; Get to INDIRECT JMP address	JMP	:enter_chosen_code:not_full_stop	CMP	(Temp),Y		; If CL = My ASC then check	BNE	:not_equal_check_1	; Next character	JMP	:name_test_loop:not_equal_check_1	CMP	#91			; If CL = Lower case then convert	BMI	:get_next_name_address	; Not lower case so skip check	SEC					SBC	#32			; Turn 'A' into capital:skip_caps_make	CMP	(Temp),Y		; Check against our letter	BEQ	:name_test_loop	; If ok check next letter:get_next_name_address	JSR	GET_TO_CODE_ADDRESS	; Move pointer	JSR	STORE_BEGIN_ADDRESS	; Store next command address	LDY	#0			; Load next byte in list	LDA	(Temp),Y	BEQ	:someone_else		; If = 0 then end of my list	DEY				; reset Y for loop	JMP	:name_test_loop	; and jump back into test name loop:enter_chosen_code	STY	text_pos	STA	text_add+1		; Store Hi Byte	INY	LDA	(Temp),Y		; Lo address of code entry	STA	text_add		; Store Lo Byte	PLA	STA	text_pos+1	PLA	STA	text_pos	PLA	STA	Temp+1	PLA	STA	Temp	JMP	(text_add)		; Jump to chosen code indirect:someone_else				; Not any of my commands	PLA	STA	text_pos+1	PLA	STA	text_pos	PLA	STA	Temp+1	PLA	STA	Temp	PLA	STA	text_add+1	PLA	STA	text_add	PLA	TAX	PLA	TAY				; reset X and Y	LDA	#04			; reset A for command	RTS				; exit.GET_TO_CODE_ADDRESS	INY				; Short cut chosen. Get to address	LDA	(Temp),Y		; Load next byte in list	CMP	#&80			; Check if top bit set	BMI	GET_TO_CODE_ADDRESS	; If not set jmp do again.	RTSSTORE_BEGIN_ADDRESS	INY				; next command.	INY				; Increment for start of next word	CLC	TYA				; Now work/store address of next	ADC	Temp			; autoload command.	STA	Temp	BCC	:skip_hi_increment	INC	Temp+1:skip_hi_increment	RTSAUTOLOAD_CODE	PLA	STA	text_add		PLA	STA	text_add+1	LDA	#0			; Set WP & Switch flags to Zero	STA	al_wp_type	STA	switch_status	LDA	#01			; Set filetype to on	STA	chime_bit		; Set chimer on	STA	filetype_off	LDA	#131			; Set default mode to on	STA	screen_mode	LDY	#0	LDA	#"*"	STA	cl_save,Y	INY:file_loader_type_loop	LDA	(&F2),Y			; GET COMMAND LINE	STA	cl_save,Y		; SAVE IT FOR LATER	CMP	#13	BNE	:not_CL_return	INY				; Now we must add the terminating	LDA	#&FF			; byte value used in FUNC_BUFFER	STA	cl_save,Y	LDA	al_wp_type		; See if WP type chosen in CL	BNE	:skip_set_default_view	; If 0 then set  View else skip	LDA	#01			; 1 indicates View is user WP	STA	al_wp_type:skip_set_default_view	LDA	switch_status	BNE	:skip_set_default_no_switches	LDA	#00  	STA	switch_status:skip_set_default_no_switches	JMP	:got_autoloader_CL:not_CL_return	CMP	#"W"			; Test for Capital W (Wordwise)	BEQ	:user_selected_wordwise	CMP	#"w"			; Test for lower w (Wordwise)	BEQ	:user_selected_wordwise	CMP	#"V"			; Test for Capital V (View)	BEQ	:user_selected_view	CMP	#"v"			; Test for lower v (View)	BEQ	:user_selected_view	CMP	#"S"			; Test for Capital S (Switches)	BEQ	:user_selects_switches	CMP	#"s"			; Test for lower s (Switches)	BEQ	:user_selects_switches	CMP	#"I"			; Test for Capital I (File OFF)	BEQ	:user_selects_filesoff	CMP	#"i"			; Test for lower i (File OFF)	BEQ	:user_selects_filesoff	CMP	#"F"			; Test for Capital F (Folio)	BEQ	:user_selected_folio	CMP	#"f"			; Test for lower f (Folio)	BEQ	:user_selected_folio	CMP	#"C"			; Test for Chime Off code	BEQ	:user_selected_chimeoff	CMP	#"c"			; Test for Chime Off code	BEQ	:user_selected_chimeoff	CMP	#"#"			; Test for ROM loaded only	BEQ	:user_selected_check_only;At this point we do a number check only.  Add more letters above ONLY!	CMP	#"8"	BPL	:back_to_CL_loop	CMP	#"0"	BMI	:back_to_CL_loop:got_screen_mode	SEC		SBC	#48	STA	screen_mode	JSR	GET_MACHINE_TYPE	CMP	#03	BMI	:back_to_CL_loop	CLC	ADC	#128	STA	screen_mode:back_to_CL_loop	INY	JMP	:file_loader_type_loop:user_selected_folio	LDA	#03			; '3' indicates Folio	STA	al_wp_type		;	JMP	:back_to_CL_loop:user_selected_wordwise	LDA	#02			; '2' indicates Wordwise+	STA	al_wp_type		; Store until Zero Page Stacked	JMP	:back_to_CL_loop:user_selected_view	LDA	#01			; '1' indicates View	STA	al_wp_type		; Store until Zero Page Stacked	JMP	:back_to_CL_loop:user_selects_switches	LDA	#01	STA	switch_status	JMP	:back_to_CL_loop:user_selects_filesoff	LDA	#0	STA	filetype_off	JMP	:back_to_CL_loop:user_selected_chimeoff	LDA	#0	STA	chime_bit	JMP	:back_to_CL_loop:user_selected_check_only	JMP	:exit_big_time	:got_autoloader_CL	LDY	#0			; Stack all of Zero Page:autoload_zp_stacker_loop	LDA	&70,Y	PHA	INY	CPY	#31	BNE	:autoload_zp_stacker_loop