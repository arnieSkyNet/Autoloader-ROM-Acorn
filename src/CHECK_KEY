DISPLAY_GRAPHICS_CHARACTER	STA	data_buffer+3		; Character to print	LDA	column_flag	STA	data_buffer+1	LDA	row_flag	STA	data_buffer+2	LDA	#31	STA	data_buffer	LDA	#&FF	STA	data_buffer+4	LDX	#>data_buffer	LDY	#<data_buffer	JSR	PRINT_TEXT	RTSCHECK_KEYS	LDA	#01	STA	chime_bit		; Enable chimer	LDA	#0	STA	column_flag	STA	row_flag	LDA	#01	STA	oscli_store		; To start at line	STA	oscli_store+2		; Start indent position	LDA	#24	STA	oscli_store+1		; To end at line	LDA	#37		STA	oscli_store+3		; Indent add number       LDA	#04       LDX	#01       LDY	#01       JSR     OSBYTE :flush_buffer	LDA	#&91			; Get character from buffer		LDX	#0			; From keyboard buffer	LDY	#&FF			; Read only from buffer	BCS	:buffer_empty	TYA				; Put character into A	TAX				; Now move character A to X	JMP	:key_has_been_pressed:buffer_empty       LDA	#21       LDX	#0       LDY	#0       JSR     OSBYTE 	LDA	#202	LDX	#32	LDY	#0	JSR	OSBYTE		LDA	switch_status	BEQ	:switches_not_used	LDA	column_flag	BNE	:switch_scanner	JSR	CHECK_FOR_SWITCH_PRESS	CPX	#0	BNE	:detected_special_user:switches_not_used	JMP	:normal_keyboard_scan:detected_special_user	JSR	DISPLAY_LEFT_SIDE	JMP	:flush_buffer:switch_scanner	LDA	row_flag	BNE	:row_down	JSR	CHECK_FOR_SWITCH_PRESS	CPX	#0	BNE	:skip_keyb_scan		JMP	:normal_keyboard_scan:skip_keyb_scan	CPX	#01	BNE	:not_row_down_do	JSR	CLEAR_ALL_COLUMNS	LDA	#31	JSR	OSWRCH	LDA	column_flag	JSR	OSWRCH	LDA	#02	JSR	OSWRCH	LDA	#130	JSR	OSWRCH	JMP	:row_down:not_row_down_do	LDA	column_flag	CMP	#38	BEQ	:not_left_side	JSR	DISPLAY_RIGHT_SIDE	JMP	:flush_buffer:not_left_side	JSR	DISPLAY_LEFT_SIDE	JMP	:flush_buffer:row_down	LDA	row_flag	CMP	#01	BPL	:no_row_fudge	LDA	#02	STA	row_flag:no_row_fudge	JSR	CHECK_FOR_SWITCH_PRESS	CPX	#0	BNE	:right_switch_pressed	JMP	:normal_keyboard_scan:right_switch_pressed	CPX	#02	BEQ	:switch_selected	JSR	CLEAR_ALL_COLUMNS	INC	row_flag	LDA	row_flag	CMP	#16	BPL	:do_not_skip_rows	CMP	#15	BMI	:do_not_skip_rows	INC	row_flag	INC	row_flag:do_not_skip_rows	CMP	#25	BNE	:not_reset_row	LDA	#02	STA	row_flag:not_reset_row	LDA	#31	JSR	OSWRCH	LDA	column_flag	JSR	OSWRCH	LDA	row_flag	JSR	OSWRCH	LDA	#130	JSR	OSWRCH	JMP	:row_down:switch_selected		LDA	row_flag	CMP	#15	BPL	:util_switch_selected	LDA	column_flag	CMP	#38	BEQ	:right_col_chosen	LDA	#63	CLC	ADC	row_flag	TAX	JMP	:key_has_been_pressed:right_col_chosen	LDA	#76		CLC	ADC	row_flag	TAX	JMP	:key_has_been_pressed:util_switch_selected			; A utility option was selected	LDA	column_flag		CMP	#38			; What column Left or Right check?	BNE	:left_util_col_chosen	LDA	row_flag		; Right hand column was selected	CMP	#17			; If row 17 then <ESCAPE> selected	BNE	:not_util_switch_esc	; Escape Not selected, check Return	LDX	#27			; Load X with escape char	JMP	:key_has_been_pressed:not_util_switch_esc			; Check to see if Return selected	CMP	#19	BNE	:can_not_do_that	; If not then no more right options	LDA	#13			; Check if return allowed	CMP	more_ret	BNE	:can_not_do_that	TAX				; Put return char into X	JMP	:key_has_been_pressed	:can_not_do_that	JMP	:flush_buffer:left_util_col_chosen	LDA	row_flag	CMP	#17	BNE	:not_switch_updir	LDX	#"^^"	JMP	:key_has_been_pressed:not_switch_updir	CMP	#21	BNE	:not_switch_new_file	LDX	#"1"	JMP	:key_has_been_pressed:not_switch_new_file	CMP	#18	BNE	:not_switch_root	LDX	#"$"	JMP	:key_has_been_pressed:not_switch_root	CMP	#19	BNE	:can_not_do_that	LDX	#"&"	JMP	:key_has_been_pressed:normal_keyboard_scan	LDA	#&81       LDX	#0       LDY	#0       JSR     OSBYTE       CPY	#&FF       BNE     :key_has_been_pressed	JMP	:flush_buffer:key_has_been_pressed       TXA	STA	key_press       CMP	#13       BEQ     :check_for_return_key:key_loop	LDA     key_storage,Y        CMP     key_press       BEQ     :key_ok       INY       CPY     num_keys        BNE     :key_loop       JMP     :flush_buffer:check_for_return_key	CMP	more_ret	BEQ	:key_ok	JMP	:flush_buffer:key_ok	LDA	key_press	TAX	LDA	#213	LDY	#0	JSR	OSBYTE 		; Set bell frequency	LDA	#7	JSR	OSWRCH       LDA	#04       LDX	#00       LDY	#01       JSR     OSBYTE	LDA	#0	STA	chime_bit	; Disable chimer       LDA     key_press        RTSDISPLAY_LEFT_SIDE	LDA	#0	STA	chime_bit	; Disable chimer	LDA	oscli_store	STA	Temp		; Line number value to start with	STA	column_flag	LDA	oscli_store+2	CLC	ADC	oscli_store+3	STA	Temp+1		; Set Indent value	LDA	#32	STA	Temp+2		; Set character to print	JSR	DISPLAY_COLUMN	LDA	oscli_store	STA	Temp		; Line number value to start with	LDA	oscli_store+2	STA	Temp+1		; Set Indent value	LDA	#130	STA	Temp+2		; Set character to print	JSR	DISPLAY_COLUMN	LDA	#01	STA	chime_bit	; Enable chimer	RTSDISPLAY_RIGHT_SIDE	LDA	#0	STA	chime_bit	; Disable chimer	LDA	oscli_store+2	CLC	ADC	oscli_store+3	STA	column_flag	LDA	oscli_store	STA	Temp		; Line number value to start with	LDA	oscli_store+2	STA	Temp+1		; Set Indent value	LDA	#32	STA	Temp+2		; Set character to print	JSR	DISPLAY_COLUMN	LDA	oscli_store	STA	Temp		; Line number value to start with	LDA	oscli_store+2	CLC	ADC	oscli_store+3	STA	Temp+1		; Set Indent value	LDA	#130	STA	Temp+2		; Set character to print	JSR	DISPLAY_COLUMN	LDA	#01	STA	chime_bit	; Enable chimer	RTSCLEAR_ALL_COLUMNS	LDA	#0	STA	chime_bit	; Disable chimer	LDA	oscli_store	STA	Temp		; Line number value to start with	LDA	oscli_store+2	STA	Temp+1		; Set Indent value	LDA	#32	STA	Temp+2		; Set character to print	JSR	DISPLAY_COLUMN	LDA	oscli_store	STA	Temp		; Line number value to start with	LDA	oscli_store+2	CLC	ADC	oscli_store+3	STA	Temp+1		; Set Indent value	LDA	#32	STA	Temp+2		; Set character to print	JSR	DISPLAY_COLUMN	LDA	#01	STA	chime_bit	; Enable chimer	RTSDISPLAY_COLUMN	INC	Temp	LDA	Temp	CMP	#15	BEQ	DISPLAY_COLUMN	CMP	#16	BEQ	DISPLAY_COLUMN	LDA	#31	JSR	OSWRCH	LDA	Temp+1			; Indent value	JSR	OSWRCH	LDA	Temp			; Line value	JSR	OSWRCH	LDA	Temp+2			; Character number	JSR	OSWRCH	LDA	Temp	CMP	oscli_store+1	BMI	DISPLAY_COLUMN	RTS