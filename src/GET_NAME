Å..........*.......*.......*......*.......*.......*.......*.......*.......*.<;list_on_label	LST	ONDECODE_SWITCH	CPX	#01			; If left switch switch then	BNE	:scan_left_right	; jump to decode.	LDA	switch_status	CMP	#01	BNE	:not_first_entry	LDA	#02			; First press of right switch	STA	switch_status		; Make switch_status 02	JSR	INVERSE_COLUMN_TOGGLE	; Default current column	LDA	#01			; Make first letter in column	STA	colour_status		; Inversed	JSR	INVERSE_ROW_TOGGLE	; Make current row inverse	LDX	#0			; Exit X = 0 indicates that no	JMP	:exit_decode_switch	; letter has been selected.:not_first_entry	JSR	INVERSE_ROW_TOGGLE	; Make current row inverse	INC	row_flag		; Increment by 2 rows	INC	row_flag	LDA	row_flag	CMP	#23	BMI	:not_beyond_row_range	LDA	#09			; Reset row_flag to default	STA	row_flag		; value:not_beyond_row_range	LDA	#01	STA	colour_status	JSR	INVERSE_ROW_TOGGLE	; Make current row inverse	LDX	#0			; Exit X = 0 indicates that no	JMP	:exit_decode_switch	; letter has been selected.:scan_left_right	LDA	switch_status		; If switch status = 1	CMP	#02			; left switched pressed	BEQ	:decode_letter		; after right switch	LDA	#01			; Indicate left switch has now	STA	switch_status		; been pressed.	JSR	INVERSE_COLUMN_TOGGLE	; Make current column default	INC	column_flag		; Increment column_flag by 2	INC	column_flag	LDA	column_flag		; Get column flag	CMP	#29	BMI	:not_beyond_range	; If less than 27 then don't	LDA	#01			; reset column back to first	STA	column_flag		; column (01):not_beyond_range	LDA	#01	STA	colour_status	JSR	INVERSE_COLUMN_TOGGLE	LDX	#0			; Exit X = 0 indicates that no	JMP	:exit_decode_switch	; letter has been selected.:decode_letter	JSR	INVERSE_ROW_TOGGLE	; Make current row default	LDA	key_storage		; Get letter selected before it is	PHA				; corrupted and stack for later.	JSR	RESET_KEYBOARD	PLA	TAX	CPX	#127			; If Character read > 127	BMI	:exit_decode_switch	; must be graphic character	JSR	DECODE_USER_CHARACTERS:exit_decode_switch	RTSINVERSE_COLUMN_TOGGLE				LDA	#0	    		; Initiaise pointer to 0	STA	func_pointer	LDY	row_flag		; Y = Row value:read_column_loop	LDX	column_flag		; X = Indent value	TYA	PHA	JSR	READ_CHARACTER	PLA	TAY	INY				; Next row of column to inverse	CPY	#22			; If row 22 of column then end	BMI	:read_column_loop	JSR	TOGGLE_COLOURS	LDA	#0	    		; Initiaise pointer to 0	STA	func_pointer	LDY	row_flag		; Y = Row value:write_column_loop	LDX	column_flag		; X = Indent value	TYA	PHA	JSR	WRITE_CHARACTER	PLA	TAY	INY				; Next row of column to inverse	CPY	#22			; If row 22 of column then end	BMI	:write_column_loop	RTSTOGGLE_COLOURS				; If colour_status = 0 DEFAULT	LDA	colour_status		; If colour_status = 1 INVERSE	BEQ	:make_default			JSR	INVERSE_COLOUR			LDA	#0			; Indicate for next time that	STA	colour_status		; colour is now INVERSED	JMP	:do_inverse_toggle	; So next it will be DEFAULTED:make_default	JSR	DEFAULT_COLOUR	LDA	#01			; Indicate for next time that	STA	colour_status		; colour is now DEFAULTED:do_inverse_toggle			; So next it will be INVERSED	RTSDEFAULT_TO_INVERSE			; If Should be INV make INV	LDA	colour_status	BEQ	:already_inversed	JSR	INVERSE_COLOUR:already_inversed	RTSINVERSE_ROW_TOGGLE	LDA	#0	    		; Initiaise pointer to 0	STA	func_pointer	LDY	row_flag		; Y = Row value	LDX	column_flag		; X = Indent value	JSR	READ_CHARACTER	JSR	TOGGLE_COLOURS	LDA	#0	    		; Initiaise pointer to 0	STA	func_pointer	LDY	row_flag		; Y = Row value	LDX	column_flag		; X = Indent value	JSR	WRITE_CHARACTER	RTSDECODE_USER_CHARACTERS	CPX	#133			; If character 133 then (return)?	BNE	:not_user_return	LDX	#13			; So 133 becomes 13	RTS:not_user_return	CPX	#132			; If character 132 then (delete)?	BNE	:not_user_delete	LDX	#127			; So 132 becomes 127	RTS:not_user_delete	CPX	#134			; If character 134 then (escape)?	BNE	:not_user_escape	LDX	#27			; So 134 becomes 27	RTS:not_user_escape	LDX	#32			; If not then must be a space 32	RTSREAD_CHARACTER				; X & Y contain position on entry	LDA	#31			; Move text cursur X,Y	JSR	OSWRCH	TXA				; A = X = Indent value	JSR	OSWRCH	TYA				; A = Y = Row value	JSR	OSWRCH	LDA	#&87			; Read character at text position	LDX	#0	LDY	#0	JSR	OSBYTE			; X has the value read	TXA	LDY	func_pointer		; pointer value to save char read	CMP	#135			; If X < 135 then write character         BMI	:skip_white_space	LDA	#32			; Write space to screen:skip_white_space	STA	key_storage,Y	INC	func_pointer	RTSWRITE_CHARACTER				; X & Y contain position on entry	LDA	#31			; Move text cursur X,Y	JSR	OSWRCH	TXA				; A = X = Indent value	JSR	OSWRCH	TYA				; A = Y = Row value	JSR	OSWRCH	LDY	func_pointer		; pointer value to save char read	LDA	key_storage,Y	JSR	OSWRCH 	INC	func_pointer	RTSCHECK_FOR_SWITCH_PRESS	LDA	Temp	PHA        LDA	#&80        LDX	#0        LDY	#0        JSR     OSBYTE 	CPX	#0	BEQ	:nothing_pressed	LDA	#07	JSR	OSWRCH	STX	Temp:let_go_switch_loop        LDA	#&80        LDX	#0        LDY	#0        JSR     OSBYTE 	CPX	Temp	BEQ	:let_go_switch_loop	LDX	Temp:nothing_pressed	PLA	STA	Temp	RTSSAVE_CURSUR_XY	LDA	#134			; Read text cursur position	LDX	#0		LDY	#0	JSR	OSBYTE	LDA	#31			; Store TAB VDU command	STA	cursur_position	STX	cursur_position+1	STY	cursur_position+2	LDA	#&FF		STA	cursur_position+3	RTSRESET_KEYBOARD	LDA	#01			; Set default indent column to 01	STA	column_flag		; Save indent value	LDA	#09			; Set default row value to 07	STA	row_flag		; Save indent value	LDA	#01			; Set to print column inverse	STA	switch_status		; Switch pressed is none	STA	colour_status		; save value	JSR	INVERSE_COLUMN_TOGGLE	; Inverse whole column of keyboard	JSR	RESTORE_TEXT_POSITION	; Put text cursur to original X,Y	RTSRESTORE_TEXT_POSITION			; Restore cursur text position	LDA	#31	JSR	OSWRCH			; Move cursur to text X,Y	LDA	cursur_position+1	JSR	OSWRCH			; Move cursur to X coordinate	LDA	cursur_position+2	JSR	OSWRCH			; Move cursur to Y coordinate	RTS	GET_NAME        STA     last_file_num		; Stores max length of string	LDA	#0	STA	chime_bit		; Disable chimer        STX     get_name_store		; Save HI and LOW address bytes        STY     get_name_store+1	; of buffer to put name at.	LDY	#0			; Set current string length to 0	STY	file_length		; Stores current length of string	JSR	SAVE_CURSUR_XY		; Read current text pos. & save	LDA	row_flag		; Check if switches used	BEQ	:get_name_loop		; If not skip keyboard display	LDX	#>keyboard_data	; Print keyboard display	LDY	#<keyboard_data	JSR	PRINT_TEXT	JSR	RESET_KEYBOARD:get_name_loop	JSR	CHECK_FOR_SWITCH_PRESS	CPX	#0			; If no switch pressed then check	BEQ	:no_decode_switch	; for key being pressed.	JSR	DECODE_SWITCH		; X = 0 no letter or X = ASC value	TXA	PHA	JSR	RESTORE_TEXT_POSITION	; Put text cursur to original X,Y	PLA	TAX	CPX	#0			; If X <> 0 then X = ASC value	BNE	:letter_accepted	; so branch to check ASC validity.:no_decode_switch			; Check if user presses a key.	LDA	#&81			; Do read key with timeout        LDX	#0			; Low timeout byte = 0        LDY	#0			; Hi  timeout byte = 0        JSR     OSBYTE			; X = ASC if key pressed	CPY	#27			; Check for escape pressed	BEQ	:check_true_escape	BCS	:get_name_loop		; No key pressed try again.:letter_accepted	TXA				; Transfer ASC in X to A	JMP	:not_exit_get_name	; No escape pressed:check_true_escape	BCC	:get_name_loop		; Not True Escape try again	LDY	#0			; Escape pressed set Y to zero	JMP	:exit_get_name:not_exit_get_name	CMP	#13			; Check for return key	BEQ	:get_name_pressed	; Return pressed branch	CMP	#127			; Check for delete key	BNE	:not_get_name_delete	; No delete so branch	LDY	file_length		; Load current string length	CPY	#0			; If zero then ignore delete key	BEQ	:get_name_loop	JSR	OSWRCH			; Do backspace and delete	JSR	SAVE_CURSUR_XY		; Read current text pos. & save		DEC	file_length		; Decrement current string length	JMP	:get_name_loop		; Jump back into main loop:not_get_name_delete	CMP	#126			; Check not to high key	BPL	:get_name_loop	CMP	#32			; Check no lower than space	BMI	:get_name_loop	LDY	file_length		; Load current string length	CPY	last_file_num		; If current = max length	BPL	:get_name_too_long	; Then name to long. Branch	STA	(get_name_store),Y	; Value OK so store	JSR	OSWRCH			; Write ASC value to screen		JSR	SAVE_CURSUR_XY		; Read current text pos. & save	INC	file_length		; Increment string length	JMP	:get_name_loop		; Jump back into main loop:get_name_too_long	LDA	#07			; Indicate with beep string	JSR	OSWRCH			; is too long.	JMP	:get_name_loop		; Jump back into main loop:get_name_pressed	LDY	file_length		; Load current string length	LDA	#13	STA	(get_name_store),Y	; Store ASC return value:exit_get_name	JSR	OSNEWL	SEC	RTS