Å..........*.......*.......*......*.......*.......*.......*.......*.......*.<USER_OSCLI		        JSR     MODE131        LDX	#>oscli_utility_head         LDY	#<oscli_utility_head 	JSR	TOP_HEADER	LDA	#0	STA	chime_bit		; Disable chime bit:oscl_loop	JSR	RESET_KEY_RATES        LDA	#"*"         JSR     OSWRCH        LDX	#>util_com        LDY	#<util_com        LDA	#78        JSR     GET_NAME         CPY	#00        BEQ     :exit_oscl        JSR     UTILITY_OSCLI_COMMAND	JSR	READ_CURRENT_MODE	CPY	#03	; If mode not 131/3 then redue whole screen	BEQ	:oscl_loop        JMP     USER_OSCLI:exit_oscl	JSR	SET_KEY_RATES        RTSUTILITY_OSCLI_COMMAND	        LDX	#>util_com        LDY	#<util_com        STX     oscli_store         STY     oscli_store+1 	LDA	#&FE        JSR     ERROR_OSCLI 	BCS	:exit_util_oscli	JSR	ERROR_DISP:exit_util_oscli        RTSUTILITY_OSGBPB_COMMAND		STA	os_temp_store	        STX     oscli_store         STY     oscli_store+1 	LDA	#&F0        JSR     ERROR_OSCLI 	BCS	:exit_util_osgbpb	LDY	#0	LDA	(&FD),Y	CMP	#191		; Error Who are you?	BNE	:norm_osgbpb_err	JSR	ERROR_DISP	JSR	OSNEWL	JSR	LOGON	JMP	PROGRAM_START:norm_osgbpb_err	JSR	ERROR_DISP:exit_util_osgbpb        RTSUTILITY_OSWORD_COMMAND		STA	os_temp_store	        STX     oscli_store         STY     oscli_store+1 	LDA	#&FD        JSR     ERROR_OSCLI 	BCS	:exit_util_osword	JSR	ERROR_DISP:exit_util_osword        RTSUTILITY_OSFILE_COMMAND	        STX     oscli_store         STY     oscli_store+1         JSR     ERROR_OSCLI 	BCS	:exit_util_osfile	JSR	ERROR_DISP	CLC:exit_util_osfile        RTSERROR_DISP           		JSR	OSNEWL        JSR     INVERSE_COLOUR        LDY	#1:error_text_loop        LDA     (&FD),Y         CMP	#0        BEQ     :press_space        JSR     OSWRCH         INY        JMP     :error_text_loop:press_space	JSR	PRESS_SPACE_BAR	RTSPRESS_SPACE_BAR        LDX	#>press_space_text        LDY	#<press_space_text        JSR     PRINT_TEXT        JSR     DEFAULT_COLOUR         JSR     OSNEWL         JSR     OSRDCH         RTSERROR_OSCLI          		STA	isdata_flag	; Store type of OS to do	LDA	os_temp_store	PHA        LDA     &202 		; Load current Break Vector LO        STA     oldvec 		; Save Break Vector LO        LDA     &203 		; Load current Break Vector HI        STA     oldvec+1	; Save Break Vector HI        TSX			; Transfer Stack address to X        STX     oldstk 		; Save stack address        STA     oldvec+1	; 	SEI			; Disable interrupts	JSR	SET_NEW_VECTORS        LDX     oscli_store 	; Load LO address of control block        LDY     oscli_store+1 	; Load HI address of control block	LDA	isdata_flag	; Load type of OS command	CMP	#&FE		; See comments for description of A	BEQ	:oscli_only	; If &FE then branch to do an OSCLI	CMP	#&F0	BEQ	:osgbpb_only	CMP	#&FD	BEQ	:osword_only	JSR	OSFILE		; Do OSFILE 'A'	SEC			; Set carry as there has been no error	JMP	:error_exit	; Jump to our exit point:osword_only	LDA	os_temp_store	JSR	OSWORD	SEC	JMP	:error_exit:osgbpb_only	LDA	os_temp_store	; Get OSgbpb number to do	JSR	OSGBPB		; Do OSgbpb 'A'	SEC	JMP	:error_exit:oscli_only		        JSR     OSCLI		; Do OSCLI         SEC			; Set carry as there has been no error:error_exit	SEI        LDA     oldvec 		; Restore old BRK vectors before exit        STA     &202         LDA     oldvec+1         STA     &203	CLI	PLA	STA	os_temp_store        RTSour_brk	SEI        LDX     oldstk 		; Restore old stack contents        TXS	CLI        CLC			; Clear carry to indicate an error        BCC     :error_exit        BRK        BRKSET_NEW_VECTORS        LDX	#>SET_SCREEN	LDY	#<SET_SCREEN	CPY	#&1B	BEQ	:ram_vector		JMP	:rom_vector:ram_vector        LDA     #>our_brk	; Load LO address of our break        STA     &202 		; Save LO address at vector        LDA     #<our_brk	; Load HI address of our break        STA     &203		; Save HI address of our break        JMP	:exit_set_vectors:rom_vector        LDA	Temp		; Save zero page locations	PHA		LDA	Temp+1	PHA	LDA	Temp+2	PHA	LDA	#>&FF03		STA	&202	LDA	#<&FF03	STA	&203	LDA	#&A8	LDX	#&00	LDY	#&FF	JSR	OSBYTE		INX	INX	INX	STX	Temp	STY	Temp+1	LDY	#0	LDA	#>our_brk	STA	(Temp),Y	INY	LDA	#<our_brk	STA	(Temp),Y	INY	LDA	&F4	STA	(Temp),Y	PLA	STA	Temp+2	PLA	STA	Temp+1	PLA	STA	Temp:exit_set_vectors	CLI			; Enable Interrupts	RTS	;	If A = 0 then OSFILE 0  Save a block of memory as a file.;	If A = 1 then OSFILE Write info. to the catalog for file name.;	If A = 2 then OSFILE Write load address only for named file.;	If A = 3 then OSFILE Write exec address only for named file.;	If A = 4 then OSFILE attributes only for an existing file.;	If A = 5 then OSFILE Read files catalog info and file type.;	If A = 6 then OSFILE delete named object.;	If A = &F0 then do an OSGBPB 'A' must equal location os_temp_store;	If A = &FD then do an OSWORD 'A' must equal location os_temp_store;	If A = &FE then do a user ERROR OSCLI.;	If A = &FF then OSFILE load the named file.CHIMER_ROUTINE	PHP	PHA	TXA	PHA	TYA	PHA	LDA	chime_bit	BEQ	:exit_chimer_routine	JSR	CHECK_TIME_FOR_CHIME:exit_chimer_routine	LDX	#>clock_par	LDY	#<clock_par		LDA	#&04	JSR	OSWORD	PLA	TAY	PLA	TAX	PLA	PLP	RTSSETUP_EVENT_CHIMING	LDA	chime_bit	BEQ	:user_wants_no_chiming	SEI	LDA	&220	STA	evevec	LDA	&221	STA	evevec+1	LDX	#>&FF30		; Extended IRQ2 address 	LDY	#<&FF30	STX	&220 	STY	&221	LDA	#&A8	LDX	#&00	LDY	#&FF	JSR	OSBYTE		STX	Temp	STY	Temp+1	LDY	#&30	LDA	#>CHIMER_ROUTINE	STA	(Temp),Y	INY	LDA	#<CHIMER_ROUTINE	STA	(Temp),Y	INY	LDA	&F4	STA	(Temp),Y	CLI	LDX	#>clock_par	LDY	#<clock_par		LDA	#&04	JSR	OSWORD	LDA	#14	LDX	#05	LDY	#0	JSR	OSBYTE:user_wants_no_chiming	RTSCHIME_OFF_CODE	LDA	#13	LDX	#05	LDY	#0	JSR	OSBYTE	SEI	LDA	evevec	STA	&220	LDA	evevec+1	STA	&221	CLI	RTSour_osword	PHP	CMP	#0	BEQ	:osword_read_line_from_input	JMP	:exit_our_osword:osword_read_line_from_input	INC	osword_count	LDA	osword_count	CMP	#11	BPL	:kick_in_view_menu	LDA	#0	JMP	:exit_our_osword:kick_in_view_menu	TXA	PHA	TYA	PHA	LDA	text_add	PHA	LDA	text_add+1	PHA	LDA	#03			; Turn off printer port. Fudge as	JSR	OSWRCH			; sometimes sends rubbish to port.	LDA	#229			; Enable Escape key action as I will	LDX	#0			; disable key when 2 presssed if in	LDY	#0			; Comments/Assesments mode.	JSR	OSBYTE	LDA	comm_ass_flag		; See if using writing a report	BEQ	:normal_view_menu	; If A = 0 then normal menu	CMP	#20	BPL	:normal_view_menu	LDX	#>rep_ass_menu	LDY	#<rep_ass_menu	JSR	PRINT_TEXT	JMP	:re_read_character:normal_view_menu	LDX	#>view_util_menu	LDY	#<view_util_menu	JSR	PRINT_TEXT:re_read_character	LDA	#201			; Enable keyboard for user.	LDX	#0			; Keyboard switched of to stop	LDY	#0			; users mucking up extended menu	JSR	OSBYTE			; setup, after selecting a file.	JSR	OSRDCH	CMP	#27	BNE	:not_view_escape	LDA	#10	STA	osword_count	JMP	:reset_do_normal_osword:not_view_escape	CMP	#"*"	BNE	:not_command_star	TAY					; Insert '*' into buffer	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDA	#"*"				; Pull '*' to print	JMP	:view_option_two:not_command_star	CMP	#"1"	BNE	:not_view_one	JMP	:view_option_one:not_view_one	CMP	#"2"	BNE	:not_view_two	JMP	:view_option_two:not_view_two	CMP	#"3"	BNE	:not_view_three	JMP	:view_option_three:not_view_three	CMP	#"4"	BNE	:not_view_four	JMP	:view_option_four:not_view_four	CMP	#"5"	BNE	:re_read_character	LDA	oldvec				; Restore old vector	STA	&20C				; values	LDA	oldvec+1	STA	&20D	LDA	#0				; Set function key pointer	STA	func_pointer			; to 0 and save value	LDX	#>setup_view_data	LDY	#<setup_view_data	JSR	INSERT_FUNC_BUFFER	LDA	#04	STA	func_pointer	LDX	#>cl_save	LDY	#<cl_save	JSR	INSERT_FUNC_BUFFER		; Insert data to f8 key	JSR	DO_FUNCTION_KEY		; Put f8 key into buffer		PLA	STA	text_add+1			; Restore zero page	PLA					; location values of	STA	text_add			; text_add & text_add+1	PLA					; Restore Y register	TAY	PLA					; Restore X register	TAX	LDA	#0	PLP					; Restore flags	JMP	(&20C)	RTS:view_option_four				; Print document command	JSR	OSWRCH	LDA	#12				; Clear screen for 	JSR	OSWRCH				; document preview	LDY	#"S"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"C"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"."	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#13	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"C"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"L"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#13	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDA	#09	STA	osword_count	JMP	:reset_do_normal_osword:view_option_three				; Print document command	JSR	OSWRCH				; Print three to screen	LDY	#"P"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"R"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"."	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#13	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"C"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"L"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#13	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDA	#09				; Set osword count. Ensures	STA	osword_count			; next osword intercept.	JMP	:reset_do_normal_osword:view_option_two				; Enter normal command	PHA	CMP	#"*"	BEQ	:norm_view_opt2		LDA	comm_ass_flag		BEQ	:norm_view_opt2	CMP	#19	BPL	:norm_view_opt2	PLA	LDA	#229			; Disable Escape key as staff are	LDX	#1			; pressing escape instead of the	LDY	#0			; return key.	JSR	OSBYTE	JSR	OSNEWL	JSR	OSNEWL	LDX	#>save_new_file_data	LDY	#<save_new_file_data	JSR	OSCLI	LDA	#138	LDX	#0	LDY	#128	JSR	OSBYTE	LDA	#06				; Set osword count. Ensure	STA	osword_count			; next osword intercepted	JMP	:reset_do_normal_osword:norm_view_opt2	PLA	JSR	OSWRCH				; Print 5 or * to screen	JSR	OSNEWL				; Move to new line	LDA	#"="				; Display VIEW prompt 	JSR	OSWRCH	LDA	#">"	JSR	OSWRCH	LDA	#10				; Set osword count. Ensure	STA	osword_count			; next osword intercepted	JMP	:reset_do_normal_osword:view_option_one				; Save current document	JSR	OSWRCH				; Print one to screen	JSR	OSNEWL				; Move down two lines	JSR	OSNEWL	LDX	#>saving_text			; Print 'Saving text'	LDY	#<saving_text			; message (reasurance)	JSR	PRINT_TEXT	LDY	#"S"					JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"A"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"."	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#13	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"C"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#"L"	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDY	#13	JSR	INSERT_KEY_BUFF_OSBYTE		; Insert character	LDA	#09				; Set osword count. Ensure	STA	osword_count			; next osword intercepted:reset_do_normal_osword	PLA	STA	text_add+1			; Restore zero page	PLA					; location values of	STA	text_add			; text_add & text_add+1	PLA					; Restore Y register	TAY	PLA					; Restore X register	TAX	LDA	#0				; Read text from input:exit_our_osword				; OSword = 0	PLP					; Restore flags register	JMP	(oldvec)			; Do normal osword command	RTSINSERT_KEY_BUFF_OSBYTE			; Y contains character that is to	LDA	#138			; be inserted into keyboard buffer	LDX	#0	JSR	OSBYTE	RTSINTERCEPT_OSWORD_VECTOR	SEI	LDA	&20C		; OSWORD vector hi byte	STA	oldvec	LDA	&20D		; OSWORD vector low byte	STA	oldvec+1	LDX	#>&FF12		; Extended vector address of OSRDCH	LDY	#<&FF12	STX	&20C 	STY	&20D	LDA	#&A8	LDX	#&00	LDY	#&FF	JSR	OSBYTE		STX	osword_vec	STY	osword_vec+1	LDY	#&12			; &12 For extended vector location	LDA	os_temp_store	STA	(osword_vec),Y	INY	LDA	os_temp_store+1	STA	(osword_vec),Y	INY	LDA	&F4	STA	(osword_vec),Y	CLI				; Enable Interrupts	LDA	#0	STA	osword_count	RTSour_osword_get	PHP	CMP	#0	BEQ	:osword_get_routine	JMP	:exit_our_osword_get:osword_get_routine	TXA				; Transfer X ready to stack	PHA				; Stack X register	TYA				; Transfer Y ready to stack	PHA				; Stack Y register	LDA	text_add		; Get contents of text_add (ZP)	PHA				; Stack zero page contents	LDA	text_add+1		; Get contents od text_add+1 (ZP)	PHA				; Stack zero page contents	LDA	#03			; Turn off printer port. Fudge as	JSR	OSWRCH			; sometimes sends rubbish to port.:our_osword_get_loop	LDY	osword_count		; Set Y pointer to zero	LDA	data_buffer,Y	TAY				; Transfer A to Y  insert keyboard	PHA				; Stack value of A for later	JSR	INSERT_KEY_BUFF_OSBYTE	INC	osword_count	PLA				; Restore value o/p to keyboard	CMP	#13			; Check if return character	BNE	:our_osword_get_loop	PLA	STA	text_add+1		; Restore zero page	PLA				; location values of	STA	text_add		; text_add & text_add+1	PLA				; Restore Y register	TAY	PLA				; Restore X register	TAX	LDY	osword_count		; Y Contains Length	LDA	#0			; A = Read line from Input	PLP				; Restore flags	CLC				; C = 0 Return terminated string	JMP	(&20C)			; (&20C)	RTS:exit_our_osword_get			; OSword = 0	PLP				; Restore flags register	JMP	(oldvec)		; Do normal osword command   	RTSREAD_CURRENT_MODE	LDA	#135	; Do osbyte 135 to check for current Mode	LDX	#0	LDY	#0	JSR	OSBYTE	RTS