G_OBJECT_TYPE_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	SET_GET_FLAGS	LDA	&70		; Users object number to test	STA	file_num	JSR	READ_OBJECT	JSR	OBJECT_TYPE	JSR	FIND_FILE_TYPE	STA	data_buffer	JMP	:exit_big_timeD_OBJECTS_CODE	PLA	STA	text_add	PLA	STA	text_add+1	PHA				; A fudge do not know why?	LDY	#10	LDX	#&FF:transfer_loop_d_code	INX	INY	LDA	(&F2),Y	STA	cl_save,X	CMP	#13		BNE	:transfer_loop_d_code	LDA	#&FF	STA	cl_save,X	LDX	#0			; Set X=0 for Init. Zero page	LDY	#0			; Stack all of Zero Page:d_objects_zp_stacker_loop	LDA	&70,Y	PHA	TXA	STA	&70,Y	INY	CPY	#31	BNE	:d_objects_zp_stacker_loop	JSR	SET_GET_FLAGS	LDA	#"D"	STA	util_store	JSR	SET_SCREEN_MODE_FLAG	JSR	MODE131	JSR	DEFINE_CHARACTERS	JSR	DISPLAY_OBJECTS_OPTIONS	LDA	key_press	CMP	#27	BNE	:not_escape_d_objects	LDA	#&FF	STA	data_buffer	JMP	:no_objects_too_return:not_escape_d_objects	LDA	data_buffer	BEQ	:no_objects_too_return	JSR	GET_OBJECT_CHOSEN	JSR	OBJECT_NAME_TRANSFER:no_objects_too_return	LDA	#26	JSR	OSWRCH	LDA	#12	JSR	OSWRCH	LDY	#32			; Reset zero page values as found.:d_objects_zp_puller_loop	PLA	STA	&6E,Y	DEY	CPY	#0	BNE	:d_objects_zp_puller_loop	JMP	:exit_big_timeG_CSD_CODE	PLA	STA	text_add	PLA	STA	text_add+1	LDA	#06			; Read CSD OSgbpb call	JSR	SETUP_OSGBPB_BLOCK	; Setsup block and calls OSgbpb	LDY	#02			; Set Y initially to two	LDA	curr_file_syst		; Get current filing system	CMP	#05			; Check if network???	BNE	:skip_set_y_three	INY				; Y must be set to three:skip_set_y_three			; Here Y = 2 or Y = 3 (pointer)	LDX	#0			; Set X pointer to 0	JSR	MOVE_DATA_INTO_BUFFER	JMP	:exit_big_timeG_DISCTITLE_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	SET_GET_FLAGS	JSR	READ_DISC_TITLE	JMP	:exit_big_timeG_USER_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	SET_GET_FLAGS	JSR	GET_USER_ID	LDX	#0	LDY	#0	JSR	MOVE_DATA_INTO_BUFFER	JMP	:exit_big_timeSET_GET_FLAGS	LDA	#"G"	STA	util_store	LDX	#0	STX	file_num	RTSG_STATION_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	SET_GET_FLAGS	JSR	GET_STATION_NUMBER	LDA	cont_blk+1	STA	data_buffer	LDA	#13	STA	data_buffer+1	JMP	:exit_big_timeMOVE_INFO_INTO_BUFFER	STX	text_add	STY	text_add+1	LDY	#0:side_buffer_loop	LDA	(text_add),Y	CMP	#&FF	BEQ	:end_side_buffer_loop	STA	data_buffer,Y	INY	JMP	:side_buffer_loop:end_side_buffer_loop	RTSG_MACHINE_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	SET_GET_FLAGS	JSR	GET_MACHINE_TYPE 	STA	text_pos	CMP	#2	BPL	:get_not_bbcB	PHA	LDX	#>mac_BBC_data	LDY	#<mac_BBC_data	JSR	MOVE_INFO_INTO_BUFFER	PLA	CMP	#1	BPL	:get_not_bbcB_series	LDA	32	STA	data_buffer,Y	INY	LDA	#"+"	STA	data_buffer,Y:get_not_bbcB_series	JMP	:get_machine_end:get_not_bbcB	LDA	text_pos	CMP	#3	BNE	:get_not_128	LDX	#>mac_master_128_data	LDY	#<mac_master_128_data	JSR	MOVE_INFO_INTO_BUFFER	JMP	:get_machine_end:get_not_128	LDA	text_pos	CMP	#4	BNE	:get_not_ET	LDX	#>mac_ET_data	LDY	#<mac_ET_data		JSR	MOVE_INFO_INTO_BUFFER	JMP	:get_machine_end:get_not_ET	LDX	#>mac_compact_data	LDY	#<mac_compact_data	JSR	MOVE_INFO_INTO_BUFFER:get_machine_end	LDA	#13	STA	data_buffer,Y	JMP	:exit_big_timeMULTIPLY_NUMBERS			; Y contains number to multiply	STA	Temp+1			; A contains other number.:mult_loop	CLC	ADC	Temp+1	DEY	CPY	#01	BNE	:mult_loop	RTSTRANSFER_TO_STORE	LDA	param_blk,Y		; Get character + Y (Y already set)	DEY				; decrement Y	CMP	#126			; If character > 126 then the end	BPL	:found_end_csd		; of the data has been found.	CMP	#33			; If character <  33 then the end	BPL	:found_end_csd		; of the data has also been found.	JMP	TRANSFER_TO_STORE	; If not then do again.:found_end_csd	INY				; Decrement Y as Y inc. earlier.:move_to_buffer	LDA	param_blk,Y		; Get character from param block	DEY	CMP	#&0A	BEQ	:skip_line_feed_adfs	STA	data_buffer,X		; Save chacter in store + pointer	DEX				; Decrement X for data store:skip_line_feed_adfs	CPY	text_add		; Contains where beginning of data	BNE	:move_to_buffer		; is in the param block.	PHA				; Incase A contains $	LDA	#"."			; Get CSD seperator	STA	data_buffer,X		; Store seperator in data	DEX				; Decrement store pointer	STX	file_num		; Save store pointer	PLA				; Test for $ later	RTSGET_BACK_INTO_CSD	LDA	file_type	CMP	#01	BEQ	:back_in_csd	LDA	#06 			; Set A to 6	STA	text_add+1		; used to move down 6 CSD's at once	LDA	#&FF			; Set A=&FF to tell routine to put	JSR	MOVE_DIR		; 'DIR ' in util store only.	LDY	#&FF			; Set Y=&FF as an inc. will set Y=0	LDX	file_num		; Get X=file_num (pointer position)	INX				; Inc. X to avoid transfering 1st ".":move_dir_loop	INY					INX	LDA	data_buffer,X		; Get character + pointer X	STA	object_name,Y		; Put character + pointer Y	CMP	#13			; Check if end of all data	BEQ	:end_of_move_back	CMP	#"."			; Check if end of csd to move to.	BNE	:move_dir_loop	DEC	text_add+1	LDA	text_add+1	CMP	#0	BNE	:move_dir_loop:end_of_move_back	PHA				; Stack A incase A=13	LDA	#13			; Set A=13	STA	object_name,Y		; Put character in csd move store	TXA				; Transfer X to A	PHA				; Stack A to keep X value.	LDX	#>util_com	LDY	#<util_com	JSR	OSCLI			; Do Oscli command	PLA				; Restore X register	TAX	PLA				; Restore A register	CMP	#13			; Check if end of move csd routine	BEQ	:back_in_csd	LDY	#&FF			; If not set Y=&FF	LDA	#06			; Reset CSD mover to 6	STA	text_add+1	JMP	:move_dir_loop		; Do all over again:back_in_csd	RTSFIND_PATHNAME_TO_CSD	LDA	#"G"			; Set to G to stop printing	STA	util_store	LDA	#01			; Value for data_transfer check	STA	text_add		; Save in zero page	LDX	#0	STX	file_type		; Set to=0	LDX	#&FF			; Set X=&FF initial pointer value	TXA				; Set A=&FF	STA	data_buffer,X		; used to indicate end of pathname	DEX				; X=&FD	LDA	#13			; Also used to indicate end buffer	STA	data_buffer,X		DEX				; X=&FC	STX	file_num		; Store first pointer value:read_csd_loop	CLC	LDA	#14	CMP	file_num	BCS	:path_too_deep		; pathname is to deep.	JSR	READ_CSD_NAME		; Read CSD name into param 	INC	file_type		; file_type=file_type+1	JSR	FILING_SYSTEM  	CMP	#08	BNE	:skip_adfs_csd_fudge	LDA	param_blk+3	 	; Load A from param to check 	JMP	:do_normal_path_exit_check:skip_adfs_csd_fudge	LDA	param_blk+2	 	; Load A from param to check :do_normal_path_exit_check	CMP	#"$"			; If A=$ then root has been reached	BEQ	:reached_root		; So branch out of loop	LDX	file_num		; (X=pointer) of where to put CSD	LDY	#12			; (Y=12) Point to start from	JSR	TRANSFER_TO_STORE	; Transfer CSD into data buffer	JSR	GO_BACKUP_DIRECTORY	; Go up a directory	JMP	:read_csd_loop:path_too_deep	JSR	GET_BACK_INTO_CSD	; Put back in initial CSD	LDA	#13			; set buffer top =13	STA	data_buffer		; to indicate no root given	LDA	#7	JSR	OSWRCH	LDA	#&FF			; On exit A=&FF indicates no       RTS				; pathname given:reached_root	JSR	FILING_SYSTEM	CMP	#08	BNE	:not_adfs_root_skip	LDX	file_num		; Load pointer value	LDA	#"$"			; Store $ at beggining of disc	STA	data_buffer,X		; Name.:not_adfs_root_skip	JSR	GET_BACK_INTO_CSD	; Put back in initial CSD	LDA	#0			; A=0 indicates everything OK!	RTSADD_DISC_TITLE	JSR	READ_DISC_TITLE		; Read disc title to param_blk	LDX	file_num		; Load pointer value into X	LDY	#16			; Load max length of disc string	DEC	text_add		; Decrement data transfer check bit	JSR	TRANSFER_TO_STORE	; Transfer disc name to buffer	INC	file_num		; Increment pointer value	LDX	file_num		; Load pointer value	LDA	#"$"			; Store $ at beggining of disc	STA	data_buffer,X		; Name.	RTSPATHNAME_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	CLEAR_DATA_BUFFER	JSR	FIND_PATHNAME_TO_CSD	BNE	:exit_pathname	JSR	FILING_SYSTEM	CMP	#08	BEQ	:skip_add_disc_t	JSR	ADD_DISC_TITLE:skip_add_disc_t	LDX	file_num	LDY	#0:mv_data_top	LDA	data_buffer,X		INX	STA	data_buffer,Y	INY	CMP	#13	BNE	:mv_data_top	LDA	#&FF	STA	data_buffer,Y:exit_pathname	LDX	#>data_buffer	LDY	#<data_buffer	JSR	PRINT_TEXT	JMP	:exit_big_timeG_PATHNAME_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	CLEAR_DATA_BUFFER	JSR	FIND_PATHNAME_TO_CSD	BNE	:exit_g_pathname	JSR	FILING_SYSTEM	CMP	#08	BEQ	:skip_add_disc_title	JSR	ADD_DISC_TITLE:skip_add_disc_title	LDX	file_num	LDY	#0:move_data_top	LDA	data_buffer,X		STA	data_buffer,Y	INY	INX	CMP	#13	BNE	:move_data_top:exit_g_pathname	JMP	:exit_big_timeNET_TEST_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	DECODE_CL_NUMBER	CMP	#&FF	BEQ	:bad_stn_number	STA	cont_blk+1	; Store station number	LDA	#01	STA	cont_blk	LDA	#0	STA	cont_blk+2	LDY	#0	LDX	#03:reloc_net_test_data	LDA	net_test_data,Y	STA	cont_blk,X	INY	INX	CMP	#13	BNE	:reloc_net_test_data	LDA	#&14	LDX	#>cont_blk		LDY	#<cont_blk	JSR	OSWORD:bad_stn_number	JMP	:exit_big_timeDECODE_CL_NUMBER	LDY	#0:get_to_object_number_loop	INY	LDA	(&F2),Y			; Load CL asc value	CMP	#":"			; Check if number or not.	BPL	:get_to_object_number_loop	LDX	#0:transfer_number_loop	LDA	(&F2),Y	CMP	#13			; If return character then	BEQ	:terminate_decoding	; Terminate decoding	CMP	#"0"	BMI	:skip_store_number	CMP	#":"	BPL	:skip_store_number	SEC				; Convert ASC number to	SBC	#48			; Straight number	STA	isdata_flag,X		; Number ok so store.	INX:skip_store_number	INY	JMP	:transfer_number_loop:bad_parameters	LDA	#&FF	RTS:terminate_decoding	STX	text_pos	LDA	isdata_flag		; Load HUNDREDS units	CPX	#01	BEQ	:end_convert_algor	LDY	#10			; Multiplication number = 10	JSR	MULTIPLY_NUMBERS	; Multiply it by Y (10)	STA	Temp+1			; Store this number       LDA	isdata_flag+1		; Load TENS units	CLC				; Clear carry (normal thing to do)	ADC	Temp+1			; Add this to the last number	CPX	#02	BEQ	:end_convert_algor	LDY	#10			; Multiplication number = 10	JSR	MULTIPLY_NUMBERS	STA	Temp+1	LDA	isdata_flag+2		; Load SINGLE units	CLC	ADC	Temp+1:end_convert_algor	STA	file_num	RTS	FASTKEY_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	SET_FASTKEY	JMP	:exit_big_timeSET_FASTKEY	LDA	#12	LDX	#02	LDY	#0	JSR	OSBYTE	LDA	#11	TAX	LDY	#0	JSR	OSBYTE	RTSGET_PATHNAME_CODE	JSR	CLEAR_DATA_BUFFER	JSR	FIND_PATHNAME_TO_CSD	BNE	:exit_path	JSR	FILING_SYSTEM	CMP	#08	BEQ	:skip_add_dtitle_2	JSR	ADD_DISC_TITLE:skip_add_dtitle_2	LDX	file_num	LDY	#0:mv_data_top_2	LDA	data_buffer,X		STA	data_buffer,Y	INY	INX	CMP	#13	BNE	:mv_data_top_2	LDA	#0:exit_path	RTSOBJECT_NAME_TRANSFER	LDX	#0		; To save at data_buffer,0. Y Set.	LDY	#01:obj_loop_enter		LDA	param_blk,Y	STA	data_buffer,X	CMP	#32	BEQ	:skip_obj_loop	CPY	#10	BEQ	:skip_obj_loop	INX	INY	JMP	:obj_loop_enter:skip_obj_loop	LDA	#13	STA	data_buffer,Y	RTSG_OBJECTS_CODE	PLA	STA	text_add	PLA	STA	text_add+1	JSR	SET_GET_FLAGS	LDA	&70	STA	file_num	JSR	READ_OBJECT	STA	&70		; Number of files left to read	JSR	OBJECT_NAME_TRANSFER	JMP	:exit_big_timeSET_SCREEN_MODE_FLAG	JSR	READ_CURRENT_MODE	CPY	#131	BEQ	:set_line_value_16	CPY	#03	BEQ	:set_line_value_16		LDA	#19	STA	screen_mode	RTS:set_line_value_16	LDA	#16	STA	screen_mode	RTS