TRANSFER_DATA_ROUTINE	JSR	INVERSE_COLOUR	LDX	#>mt_mode_heading	LDY	#<mt_mode_heading	JSR	PRINT_TEXT	LDA	curr_file_syst	STA	cfs_tran		; Save current filing system	CMP	#05			; If CFS=NET skip get drive 	BEQ	:skip_get_drive_number	; current drive number	LDA	#06			; reason code 6 = read CSD	JSR	SETUP_OSGBPB_BLOCK	; Read CSD & Drive number	LDA	param_blk+1		; Contains ASC of drive number.	STA	drive_num		; Save current drive number:skip_get_drive_number	LDA	key_press		; Contains option selected.	CMP	#"1"	BEQ	:adfs_to_net		; ADFS to NET was selected	JMP	:check_for_option_2:adfs_to_net	LDX	#>mt_adfs_net	LDY	#<mt_adfs_net		JSR	PRINT_TEXT	JSR	DEFAULT_COLOUR	LDX	#>main_window_data	LDY	#<main_window_data	JSR	PRINT_TEXT	LDA	#08			; Set source CFS as ADFS = 8	STA	cfs_tran+1		; Save in CFS source	JSR	ADFS_SELECT		; Select ADFS drive number	CMP	#27			; 'A' contains drive No. or Escape	BNE	:no_exit_option_1	JMP	:end_transfer_routine:no_exit_option_1	STA	drive_num+1		; Save Source drive number	LDA	#05			; Set destination CFS as NET	STA	cfs_tran+2	JSR	SELECT_ROOT	JSR	CATALOG_SELECT	JMP	:end_transfer_routine:check_for_option_2	CMP	#"2"	BEQ	:disc_to_net		; DISC to NET was selected	JMP	:check_for_option_3:disc_to_net	LDX	#>mt_disc_net	LDY	#<mt_disc_net	JSR	ALTER_TRANSFER_HEADER_FUDGE	LDA	#04			; Set source CFS as DISC = 4	STA	cfs_tran+1		; Save in CFS source	JSR	DFS_SELECT		; Select DISC drive number	CMP	#27			; 'A' contains drive No. or Escape	BNE	:no_exit_option_2	JMP	:end_transfer_routine:no_exit_option_2	STA	drive_num+1		; Save Source drive number	LDA	#05			; Set destination CFS as NET	STA	cfs_tran+2		; Save in CFS destination	JSR	CATALOG_SELECT	JMP	:end_transfer_routine:check_for_option_3	CMP	#"3"	BEQ	:adfs_to_disc		; ADFS to DISC was selected	JMP	:check_for_option_4:adfs_to_disc	LDX	#>mt_adfs_disc	LDY	#<mt_adfs_disc	JSR	ALTER_TRANSFER_HEADER_FUDGE	LDA	#08			; Set source CFS as ADFS = 8	STA	cfs_tran+1		; Save in CFS source	JSR	ADFS_SELECT		; Select ADFS drive number	CMP	#27			; 'A' contains drive No. or Escape	BNE	:no_exit_option_3	JMP	:end_transfer_routine:no_exit_option_3	STA	drive_num+1		; Save Source drive number	LDA	#04			; Set destination CFS as DISC	STA	cfs_tran+2		; Save in CFS destination	LDX	#>main_window_data	; Clear main screen at define	LDY	#<main_window_data	; main window.	JSR	PRINT_TEXT	JSR	DFS_SELECT		; Select DISC drive number	CMP	#27			; 'A' contains drive No. or Escape	BNE	:no_exit_option_4	JMP	:end_transfer_routine:no_exit_option_4	STA	drive_num+2		; Save destination drive number	JSR	SELECT_ROOT	JSR	CATALOG_SELECT	JMP	:end_transfer_routine:check_for_option_4	CMP	#"4"	BEQ	:net_to_disc		; NET to DISC was selected	JMP	:check_for_option_5:net_to_disc	LDX	#>mt_net_disc	LDY	#<mt_net_disc	JSR	ALTER_TRANSFER_HEADER_FUDGE	LDA	#05			; Set source CFS as NET = 5	STA	cfs_tran+1		; Save in CFS source	LDA	#04			; Set destination CFS as DISC = 4	STA	cfs_tran+2		; Save in CFS destination	JSR	DFS_SELECT		; Select DISC drive number	CMP	#27			; 'A' contains drive No. or Escape	BNE	:no_exit_option_5	JMP	:end_transfer_routine:no_exit_option_5	STA	drive_num+2		; Save destination drive number	JSR	CATALOG_SELECT	JMP	:end_transfer_routine:check_for_option_5	CMP	#"5"	BEQ	:net_to_adfs		; NET to ADFS was selected	JMP	:check_for_option_6:net_to_adfs	LDX	#>mt_net_adfs	LDY	#<mt_net_adfs	JSR	ALTER_TRANSFER_HEADER_FUDGE	LDA	#05			; Set source CFS as NET = 5	STA	cfs_tran+1		; Save in CFS source	LDA	#08			; Set destination CFS as ADFS = 8	STA	cfs_tran+2		; Save in CFS destination	JSR	ADFS_SELECT		; Select ADFS drive number	CMP	#27			; 'A' contains drive No. or Escape	BEQ	:end_transfer_routine	STA	drive_num+2		; Save destination drive number	JSR	SELECT_ROOT	JSR	CATALOG_SELECT	JMP	:end_transfer_routine:check_for_option_6			; DISC to ADFS was selected	LDX	#>mt_disc_adfs	LDY	#<mt_disc_adfs	JSR	ALTER_TRANSFER_HEADER_FUDGE	LDA	#04			; Set source CFS as DISC = 4	STA	cfs_tran+1		; Save in CFS source	JSR	DFS_SELECT		; Select DISC drive number	CMP	#27			; 'A' contains drive No. or Escape	BEQ	:end_transfer_routine	STA	drive_num+1		; Save Source drive number	LDA	#08			; Set destination CFS as ADFS = 8	STA	cfs_tran+2		; Save in CFS destination	LDX	#>main_window_data	; Clear main screen at define	LDY	#<main_window_data	; main window.	JSR	PRINT_TEXT	JSR	ADFS_SELECT		; Select ADFS drive number	CMP	#27			; 'A' contains drive No. or Escape	BEQ	:end_transfer_routine	STA	drive_num+2		; Save destination drive number	JSR	SELECT_ROOT	JSR	CATALOG_SELECT:end_transfer_routine	JSR	CURSUR_OFF	JSR	SET_KEY_RATES	RTSCATALOG_SELECT	LDY	#0			; Reset catalog start parameters	STY	first_num	STY	file_num	LDX	#01	JSR	SWITCH_TO_CFS_CHOSEN	; Switch to Source as X = 1	JSR	GET_TRANSFER_OBJECT	; Transfer completed here	LDA	key_press	CMP	#27	BNE	CATALOG_SELECT	LDX	#0			; Switch back into original CFS	JSR	SWITCH_TO_CFS_CHOSEN		RTSGET_TRANSFER_OBJECT	JSR	DISPLAY_OBJECTS_OPTIONS	LDA	key_press	CMP	#27	BEQ	:fin_adfs1	JSR	GET_OBJECT_CHOSEN	JSR	OBJECT_TYPE	LDA	file_length+1	CMP	#&69			; Check file not to big	BMI	:do_the_adfs1_load	JSR	PRINT_FILE_TOO_BIG		JMP	:fin_adfs1:do_the_adfs1_load	JSR	LOAD_FILE_CHOSEN	; Load file into memory	LDX	#02			; Switch to destination as X = 2	JSR	SWITCH_TO_CFS_CHOSEN	JSR	SAVE_FILE_CHOSEN:fin_adfs1      	RTS; On entry X contians filing system to enter:-; X = 0 (Enter Original CFS); X = 1 (Enter Source Filing System); X = 2 (Enter Destination Filing System); CFS	contains original filing system. Return to CFS when finished.; CFS+1	contains source filing system.; CFS+2 contains destination filing system.; key_press = 0 means get drive number from 'drive_num' + 0; key_press = 1 means get drive number from 'drive_num' + 1; key_press = 2 means get drive number from 'drive_num' + 2; data_buffer must contain root for ADFS for mountingSWITCH_TO_CFS_CHOSEN		TXA	PHA	LDA	cfs_tran,X	CMP	#05			BNE	:not_enter_network_fs	; If not Net then check for next	PLA				; Reset stack (Dr.No. not needed)	LDX	#>switch_net		; Get data "*NET" address ready	LDY	#<switch_net		; to enter filing system	STX	oscli_store	STY	oscli_store+1	LDA	#&FE	JSR	ERROR_OSCLI		; Enter filing system	RTS:not_enter_network_fs	CMP	#08	BNE	:not_enter_adfs_fs	; If not ADFS then check for next	LDX	#>switch_adfs		; Get data "*FADFS" address ready	LDY	#<switch_adfs		; to enter filing system	STX	oscli_store	STY	oscli_store+1	LDA	#&FE	JSR	ERROR_OSCLI		; Enter filing system	PLA	LDX	#>mount_data	LDY	#<mount_data	JSR	DISC_MOVE_RELOCATE	; Switch to a drive	LDX	#>data_buffer	LDY	#<data_buffer	STX	oscli_store	STY	oscli_store+1	LDA	#&FE	JSR	ERROR_OSCLI		; Enter to ADFS root.	RTS:not_enter_adfs_fs	CMP	#04	BNE	:were_in_bug_trouble	; If not DISC then do something!	LDX	#>switch_dfs		; Get data "*DISC" address ready	LDY	#<switch_dfs		; to enter filing system	STX	oscli_store	STY	oscli_store+1	LDA	#&FE	JSR	ERROR_OSCLI		; Enter filing system	PLA	LDX	#>drive_data	LDY	#<drive_data	JSR	DISC_MOVE_RELOCATE	; Switch to a drive	RTS:were_in_bug_trouble	RTSLOAD_FILE_CHOSEN	JSR	OSNEWL	LDX	#>loading_text	LDY	#<loading_text	JSR	PRINT_TEXT	LDA	#&00		; Low address byte '00' of address '1B00'	STA	cont_blk+2		LDA	#&1B		; High address byte '1B' of address '1B00'	STA	cont_blk+3	LDA	#00	LDY	#04:clear_block_loop	STA	cont_blk,Y	INY	CPY	#18	BNE	:clear_block_loop	LDX	#>cont_blk	LDY	#<cont_blk	LDA	#&FF	JSR	OSFILE	RTSSAVE_FILE_CHOSEN	LDA	cfs_tran+2	CMP	#04	BNE	:skip_name_cromp	LDA	#13	STA	name_store+7	; If DFS then cromp name to length of 7:skip_name_cromp	LDX	#>saving_text	LDY	#<saving_text	JSR	PRINT_TEXT	LDX	#0	LDY	#02:address_transfer_2	LDA     load_address,X	; Get load/execute address	STA     cont_blk,Y	; Store load/execute address	INY	INX	CPY	#10	BNE	:address_transfer_2	LDA	#&00		; Write start address LO of data for save	STA	cont_blk+10	LDA	#&1B		; Write start address HI of data for save	STA	cont_blk+11	LDA	#00		; Data in 2nd processor if active	STA	cont_blk+12	STA	cont_blk+13	LDA	file_length	; Get LO byte of file length	STA	cont_blk+14	; Store LO byte of file length	LDA	file_length+1	; Get HI byte of file length	CLC	ADC	#&1B		; Add HI byte to start address of data	STA	cont_blk+15	; Store HI byte of file length	LDA	file_length+2	CLC	ADC	#00	STA	cont_blk+16	LDA	file_length+3	CLC	ADC	#00	STA	cont_blk+17	LDX	#>name_store	; Get filename address	LDY	#<name_store	STX	cont_blk	; Store filename address	STY	cont_blk+1	LDY	#0:end_object_name_loop	LDA	name_store,Y	CMP	#33	BMI	:found_name_end	CMP	#126	BPL	:found_name_end	INY	JMP	:end_object_name_loop:found_name_end	LDA	#13	STA	name_store,Y	LDX	#>cont_blk	LDY	#<cont_blk	LDA	#0		; Do OSFILE save block memory	JSR	OSFILE	RTSPRINT_FILE_TOO_BIG	LDX	#>file_too_big_text	LDY	#<file_too_big_text	JSR	PRINT_TEXT	JSR	OSNEWL	JSR	PRESS_SPACE_BAR	RTSPOSITION_CURSUR_MT	LDX	#>util_com		; Address of TAB and parameters	LDY	#<util_com	JSR	PRINT_TEXT	INC	util_com+2		; Increment line number by two	INC	util_com+2		; for next text position	INC	util_com+3		; Increment text option number	RTSALTER_TRANSFER_HEADER_FUDGE	JSR	PRINT_TEXT		; Print text at cursur postion	LDA	#"*"			; Now print **	JSR	OSWRCH	JSR	OSWRCH	JSR	DEFAULT_COLOUR		; Switch back to default colour	LDX	#>main_window_data	; Clear main screen at define	LDY	#<main_window_data	; main window.	JSR	PRINT_TEXT	RTSMEDIA_TRANSFER_MENU	LDX	#>main_window_data	LDY	#<main_window_data	JSR	PRINT_TEXT	LDA	#31			; Store TAB code	STA	util_com	LDA	#06			; Store Indent number	STA	util_com+1	LDA	#01			; Store Line number	STA	util_com+2	LDA	#"1"			; Store option number	STA	util_com+3	LDA	#")"			; Store bracket code	STA	util_com+4	LDA	#&FF			; Store terminating code	STA	util_com+5	JSR	POSITION_CURSUR_MT	LDX	#>mt_adfs_net	LDY	#<mt_adfs_net	JSR	PRINT_TEXT	JSR	POSITION_CURSUR_MT	LDX	#>mt_disc_net	LDY	#<mt_disc_net	JSR	PRINT_TEXT	JSR	POSITION_CURSUR_MT	LDX	#>mt_adfs_disc	LDY	#<mt_adfs_disc	JSR	PRINT_TEXT	JSR	POSITION_CURSUR_MT	LDX	#>mt_net_disc	LDY	#<mt_net_disc	JSR	PRINT_TEXT	JSR	POSITION_CURSUR_MT	LDX	#>mt_net_adfs	LDY	#<mt_net_adfs	JSR	PRINT_TEXT	JSR	POSITION_CURSUR_MT	LDX	#>mt_disc_adfs	LDY	#<mt_disc_adfs	JSR	PRINT_TEXT	JSR	OPT_WINDOW	LDA	#31	JSR	OSWRCH	JSR	OSWRCH	LDA	#01	JSR	OSWRCH	LDX	#>escape_option_text	LDY	#<escape_option_text	JSR	PRINT_TEXT	LDA	#27	STA	key_storage	LDA	#"1"	STA	key_storage+1	LDA	#"2"	STA	key_storage+2	LDA	#"3"	STA	key_storage+3	LDA	#"4"	STA	key_storage+4	LDA	#"5"	STA	key_storage+5	LDA	#"6"	STA	key_storage+6 	LDA	#07	STA	num_keys	LDA	util_store	STA	Temp	LDA	#0	STA	util_store	JSR	CHECK_KEYS	LDA	Temp	STA	util_store	RTSSELECT_ROOT	JSR	OPT_WINDOW	LDX	#>trans_adfs_root_text	LDY	#<trans_adfs_root_text	JSR	PRINT_TEXT	LDA	#60	LDX	#>data_buffer	LDY	#<data_buffer	LDA	#"D"	STA	data_buffer	INX	LDA	#"I"	STA	data_buffer+1	INX	LDA	#"R"	STA	data_buffer+2	INX	LDA	#" "	STA	data_buffer+3	INX	JSR	GET_NAME	CPY	#0	BNE	:exit_root_get	LDA	#"$"	STA	data_buffer+4	LDA	#13	STA	data_buffer+5:exit_root_get	RTS